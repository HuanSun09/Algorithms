This file provides MAGMA code for this paper
[Huan Sun, Qin Yue, Xue Jia, and Chengju Li, Decoding algorithms of  twisted GRS codes and twisted Goppa codes]
A. The MAGMA code  in the Algorithm 1:

function euclidean(t, g, S)
i:=2;
F:=BaseRing(g);
P:=PolynomialRing(F);
q:=[P!0, 0];
r:=[g, S];
u:=[P!1, 0];
w:=[P!0, 1];
while (r[i] ne 0) and (Degree(r[i]) ge t/2) do 
i:=i+1;
q[i]:=r[i-2] div r[i-1];
r[i]:=r[i-2] mod r[i-1];
u[i]:=u[i-2]-q[i]*u[i-1];
w[i]:=w[i-2]-q[i]*w[i-1];
end while;
return([r[i-1],r[i],w[i-1],w[i]]);
end function;


p:=3;                      //input parameter p of finite field Fp
m:=2;                      //input m such that q=p^m
t:=2;                      //input t
n:=4;                      //input the length n of code
K:=FiniteField(p);
F<z>:=ext<K|m>;
P<x> := PolynomialRing(F);
a:= Vector(F,n,[1,z,z^2,z^4]);    //input a 
v:=Vector(F,n,[z^2,1,1,z^3]);     //input v
eta:=z;                           //input eta such that the code is MDS
y:=Vector(F,[1,1,1,1]);             //input received vector y

H:= ZeroMatrix(F, t, n);
for j in [1..n] do
    H[1,j]:=v[j]*(1+eta*(a[j])^t);
  end for;
for i in [2..t] do
  for j in [1..n] do
    H[i,j]:=v[j]*(a[j])^(i-1);
  end for;
end for;
H;

Y:=Transpose(H);
s:=y*Y;
s;
S:=0;
for i in [1..t] do
   S:=S+s[i]*x^(i-1);
end for;
S;
g:=x^t;
b:=euclidean(t, g, S);
sigma:=b[4];
tau:=b[2];
J:={};
e:=ZeroMatrix(F,1,n)[1];


if Degree(b[4]) lt t/2 then
   for i in [1..n] do
      if Evaluate(sigma, (a[i])^(-1)) eq 0 then
         Include(~J,i);
         e[i]:=-a[i]*Evaluate(tau, (a[i])^(-1))/(v[i]*Evaluate(Derivative(sigma), (a[i])^(-1)));
      end if;
   end for;

elif Degree(b[4]) eq t/2 then
  h:=0;
  for i in [1..n] do
      if Evaluate(sigma, (a[i])^(-1)) eq 0 then
         Include(~J,i);
         e[i]:=-a[i]*Evaluate(tau, (a[i])^(-1))/(v[i]*Evaluate(Derivative(sigma), (a[i])^(-1)));
         h:=h+eta*v[i]*e[i]*(a[i])^t;
      end if;
   end for;

   for j in [0..(p^m-1)] do
   if (#J eq Degree(sigma)) and (tau div sigma eq h) then
      break;
   else
      sigma:=b[4]+z^j*b[3];
      tau:=b[2]+z^j*b[1];
      h:=0;J:={};e:=ZeroMatrix(F,1,n)[1];
        for i in [1..n] do
          if Evaluate(sigma, (a[i])^(-1)) eq 0 then
            Include(~J,i);
            e[i]:=-a[i]*Evaluate(tau, (a[i])^(-1))/(v[i]*Evaluate(Derivative(sigma), (a[i])^(-1)));
            h:=h+eta*v[i]*e[i]*(a[i])^t;
          end if;
        end for;
   end if;
   end for;
end if; 
e;
c:=y-e;
c;

